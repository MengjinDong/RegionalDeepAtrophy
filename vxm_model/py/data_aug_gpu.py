# 3D random thin-plate-spline from Jiancong Wang.
# For an intro to thin-plate-spline, see 30:00 to 38:00
# https://www.youtube.com/watch?v=8zSPmkPqwWs
import scipy.spatial.distance as ssd
import numpy as np
import torch
import torch.nn as nn
import torch.nn.functional as F
import random
from scipy import ndimage

class TPSRandomSampler3D(nn.Module):

    def __init__(self, height, width, depth,
                 vertical_points=10, horizontal_points=10, depth_points=10,
                 rotsd=0.0, scalesd=0.0, transsd=0.1, warpsd=(0.001, 0.005),
                 cache_size=1000, cache_evict_prob=0.01, pad=True, device=None):
        super(TPSRandomSampler3D, self).__init__()

        self.input_height = height
        self.input_width = width
        self.input_depth = depth

        self.h_pad = 0
        self.w_pad = 0
        self.d_pad = 0
        if pad:
          self.h_pad = self.input_height // 2
          self.w_pad = self.input_width // 2
          self.d_pad = self.input_depth // 2

        self.height = self.input_height + self.h_pad
        self.width = self.input_width + self.w_pad
        self.depth = self.input_depth + self.d_pad

        self.vertical_points = vertical_points
        self.horizontal_points = horizontal_points
        self.depth_points = depth_points

        self.rotsd = rotsd
        self.scalesd = scalesd
        self.transsd = transsd
        self.warpsd = warpsd
        self.cache_size = cache_size
        self.cache_evict_prob = cache_evict_prob

        # Grid generator. This thing stored the thin-plate-spline kernel given 
        # the height/width/vertical_points/horizontal_points. 
        self.tps = TPSGridGen3D(
            self.height, self.width, self.depth,
            vertical_points, horizontal_points, depth_points)

        self.cache = [None] * self.cache_size if self.cache_size > 0 else []

        self.pad = pad

        self.device = device


    def _sample_grid(self):
        # Returns randomly sampled TPS-grid params of size (Hc*Wc+3)x2.
        # This contains the affine components and random components
        W = sample_tps_w_3D(
            self.vertical_points, self.horizontal_points, self.depth_points,
            self.warpsd,
            self.rotsd, self.scalesd, self.transsd)
        W = torch.from_numpy(W.astype(np.float32))
        # generate grid
        # The forward of gridgen receive the affine and random parameter generated 
        # by the sample_tps_w and returned the perturbed grid
        grid = self.tps(W[None])
        return grid


    # For each sample, sample its own deformation grid
    # This simply cache couple deformed grid. When the cache is full, no new random grid
    # will be generated by just randomly picked one old one.
    def _get_grids(self, batch_size):
        grids = []
        for i in range(batch_size):
            # cache_evict_prob: Has certain probability that new grid get generated.
            save_result = self.cache_size!= 0
            entry = random.randint(0, self.cache_size - 1) if save_result else 0
            if not save_result or self.cache[entry] is None or random.random() < self.cache_evict_prob:
                grid = self._sample_grid()
                
                if save_result:
                    self.cache[entry] = grid
            else:
                grid = self.cache[entry]
            grids.append(grid)
        grids = torch.cat(grids)
        return grids


    def forward(self, input):
        # If device has been specified, ship data to there
        if self.device is not None:
            input = input.to(self.device)

        # get TPS grids
        batch_size = input.size(0)
        grids = self._get_grids(batch_size)
        
        # Ship the grid to the same device as input
        grids = grids.to(input.device)

        # Pad, sample, unpad
        input = F.pad(input, (self.h_pad, self.h_pad, 
                              self.w_pad, self.w_pad,
                              self.d_pad, self.d_pad), mode='replicate')
        
        # The pytorch official implementation of giving a grid and a data, sample position
        input = F.grid_sample(input, grids) 
        # This will sample the grid in input. The grid in normalized coordinate (-1, 1). 
        # This returns the size same as grid. Also it supports 3D image. Heck this is awesome.
        input = F.pad(input, (-self.h_pad, -self.h_pad, 
                              -self.w_pad, -self.w_pad,
                              -self.d_pad, -self.d_pad))
        # Can pad with minus length?! Damn...

        return input

    # This is wrapper function that fit for tensorflow use.
    def forward_py(self, input):
        with torch.no_grad():
            input = torch.from_numpy(input)
            input = input.permute([0, 4, 1, 2, 3]) # [b, h, w, c] -> [b, c, h, w]
            input = self.forward(input)
            input = input.permute([0, 2, 3, 4, 1]) # [b, c, h, w] -> [b, h, w, c]
            input = input.numpy()
            return input
    
    # This is wrapper function that fit for pytorch preprocessing use.
    def forward_torch(self, input, device = None):
        with torch.no_grad():
            input = torch.from_numpy(input)
            
            if device is not None:
                input = input.cuda(device = device)
            input = self.forward(input)
            input = input.cpu().numpy()
            return input


# Grid generator. This thing given the affine and random parameter 
# generate perturbed grid.
# If use a grid as large as the original image, the matrix will be huge. A more 
# reasonable thing to do is to use a downsized grid, apply the W on the downsampled
# grid and upsample it back.            
class TPSGridGen3D(nn.Module):
    def __init__(self, Ho, Wo, Do, Hc, Wc, Dc, scale_factor = 0.2):
        """
        Ho,Wo,Do: height/width/depth of the output tensor (grid dimensions).
        Hc,Wc,Dc: height/width/depth of the control-point grid.
    
        Assumes for simplicity that the control points lie on a regular grid.
        Can be made more general.
        """
        super(TPSGridGen3D, self).__init__()
        
        self.scale_factor = scale_factor
        self._raw_hwd = (Ho, Wo, Do)
        
        Ho = int(Ho*scale_factor)
        Wo = int(Wo*scale_factor)
        Do = int(Do*scale_factor)
        
        self._grid_hwd = (Ho, Wo, Do)        
        
        self._cp_hwd = (Hc, Wc, Dc)
    
        # The grid should be same size as the image. Except in pytorch the warping function used a normalized 
        # coordinate (-1, 1)
        # initialize the grid:
        xx, yy, zz = np.meshgrid(np.linspace(-1, 1, Ho), np.linspace(-1, 1, Wo), np.linspace(-1, 1, Do), indexing='ij')
        self._grid = np.c_[xx.flatten(), yy.flatten(), zz.flatten()].astype(np.float32)  # Nx3
        self._n_grid = self._grid.shape[0]
    
        # The number of control point should be must smaller than the grid. 
        # The control point placed regularly.
        # initialize the control points:
        xx, yy, zz = np.meshgrid(np.linspace(-1, 1, Hc), np.linspace(-1, 1, Wc), np.linspace(-1, 1, Dc), indexing='ij')
        self._control_pts = np.c_[
            xx.flatten(), yy.flatten(), zz.flatten()].astype(np.float32)  # Mx3
        self._n_cp = self._control_pts.shape[0]
    
        # compute the pair-wise distances b/w control-points and grid-points:
        Dx = ssd.cdist(self._grid, self._control_pts, metric='sqeuclidean')  # NxM
    
        # create the tps kernel:
        # real_min = 100 * np.finfo(np.float32).min
        real_min = 1e-8
        Dx = np.clip(Dx, real_min, None)  # avoid log(0)
        Kp = np.log(Dx) * Dx # the radial basis function
        Os = np.ones((self._grid.shape[0]))
        
        # c_: Translates slice objects to concatenation along the second axis.
        # https://docs.scipy.org/doc/numpy/reference/generated/numpy.c_.html
        L = np.c_[Kp, np.ones((self._n_grid, 1), dtype=np.float32),
                  self._grid]  # Nx(M+4), 4 being 1, x, y, z
        self._L = torch.from_numpy(L.astype(np.float32))  # Nx(M+4), 4 being 1, x, y, z
    

    def forward(self, w_tps):
        """
        W_TPS: Bx(M+4)x3 sized tensor of tps-transformation params.
                here `M` is the number of control-points.
                    `B` is the batch-size.
    
        Returns an BxHoxWoxDox3 tensor of grid coordinates.
        """
        assert w_tps.shape[1] - 4 == self._n_cp
        batch_size = w_tps.shape[0]
        tfm_grid = torch.matmul(self._L, w_tps) # warp points
        # The parameter of the thin-plate-spline is the w_tps. The kernel L 
        # including the distance between grid/control points and the coordinate 
        # of the grid is prefixed. 
        tfm_grid = tfm_grid.flip(2).permute(0, 2, 1).reshape(
            (batch_size, 3, self._grid_hwd[0], self._grid_hwd[1], self._grid_hwd[2]))
        
        # Upsample the grid to the original size
        tfm_grid = torch.nn.functional.interpolate(tfm_grid, size=self._raw_hwd, mode='trilinear')
        tfm_grid = tfm_grid.permute(0, 2, 3, 4, 1)
        
        return tfm_grid


# This function seems to sample random w_tps to be used in the TPSGridGen.
# The thin-plate-spline contains two part: the weight for radial basis function 
# and the affine parameters.
def sample_tps_w_3D(Hc, Wc, Dc, warpsd, rotsd, scalesd, transsd):
    """
    Hc, Wc, Dc: height/width/depth of the control-point grid.
    Returns randomly sampled TPS-grid params of size (Hc*Wc*Dc+4)x3.

    Params:
      WARPSD: 2-tuple
      {ROT/SCALE/TRANS}-SD: 1-tuple of standard devs.
    """
    Nc = Hc * Wc * Dc  # no of control-pots
    # non-linear component: weight for the radial basis function
    mask = (np.random.rand(Nc, 3) > 0.5).astype(np.float32)
    W = warpsd[0] * np.random.randn(Nc, 3) + \
        warpsd[1] * (mask * np.random.randn(Nc, 3))
    
    # affine component:
    # Scaling, Rotation, Translation, 
    # The formula for rotation matrix with 3 angle is here
    # http://planning.cs.uiuc.edu/node102.html
    rnd = np.random.randn
    a, b, r = np.deg2rad(rnd() * rotsd), np.deg2rad(rnd() * rotsd), np.deg2rad(rnd() * rotsd)
    sc = 1.0 + rnd() * scalesd
    aff = [[transsd*rnd(),      transsd*rnd(),   transsd*rnd()],
           [sc * np.cos(a) * np.cos(b),   sc * (np.cos(a) * np.sin(b) * np.sin(r) - np.sin(a) * np.cos(r)),  sc * (np.cos(a) * np.sin(b) * np.cos(r) + np.sin(a) * np.sin(r))],
           [sc * np.sin(a) * np.cos(b),   sc * (np.sin(a) * np.sin(b) * np.sin(r) + np.cos(a) * np.cos(r)),  sc * (np.sin(a) * np.sin(b) * np.cos(r) - np.cos(a) * np.sin(r))],
           [sc * -np.sin(b)           ,   sc * np.cos(b) * np.sin(r)                                      ,  sc * np.cos(b) * np.cos(r)]
           ]
    W = np.r_[W, aff] # Concat the random component and affine components
    return W
